#!/usr/bin/env node

/**
 * üîç An√°lise de Lacunas de Conte√∫do
 * Compara nossa documenta√ß√£o com a documenta√ß√£o oficial do n8n
 * e identifica conte√∫do faltante ou desatualizado
 */

const fs = require('fs');
const path = require('path');
require('dotenv').config();

const DOCS_PATH = path.join(__dirname, '..', 'docs');
const REPO_OWNER = process.env.REPO_OWNER || 'tatyquebralayout';
const REPO_NAME = process.env.REPO_NAME || 'n8n-Doc-pt-BR';

// Mapeamento da documenta√ß√£o oficial do n8n
const OFFICIAL_DOCS_STRUCTURE = {
  'getting-started': {
    priority: 'critical',
    pages: [
      'quickstarts',
      'introduction',
      'choose-your-n8n',
      'video-courses',
      'text-courses'
    ],
    description: 'Primeiros passos essenciais'
  },
  'using-n8n': {
    priority: 'high',
    pages: [
      'interface/editor-ui',
      'executions',
      'expressions',
      'variables',
      'credentials',
      'workflows'
    ],
    description: 'Como usar o n8n'
  },
  'integrations': {
    priority: 'critical',
    pages: [
      'builtin-nodes',
      'app-nodes',
      'trigger-nodes',
      'community-nodes',
      'creating-nodes'
    ],
    description: 'Integra√ß√µes e nodes'
  },
  'hosting': {
    priority: 'high',
    pages: [
      'installation',
      'configuration',
      'security',
      'scaling',
      'database'
    ],
    description: 'Instala√ß√£o e hosting'
  },
  'data': {
    priority: 'medium',
    pages: [
      'data-structure',
      'data-flow',
      'data-mapping',
      'binary-data',
      'data-editing'
    ],
    description: 'Manipula√ß√£o de dados'
  },
  'flow-logic': {
    priority: 'medium',
    pages: [
      'splitting',
      'merging',
      'looping',
      'error-handling',
      'waiting',
      'subworkflows'
    ],
    description: 'L√≥gica de fluxo'
  },
  'advanced-ai': {
    priority: 'high',
    pages: [
      'ai-tutorial',
      'langchain',
      'examples',
      'evaluations'
    ],
    description: 'IA avan√ßada'
  },
  'api': {
    priority: 'medium',
    pages: [
      'authentication',
      'endpoints',
      'playground',
      'pagination'
    ],
    description: 'API REST'
  },
  'embed': {
    priority: 'low',
    pages: [
      'prerequisites',
      'configuration',
      'deployment',
      'management'
    ],
    description: 'Incorpora√ß√£o'
  },
  'community': {
    priority: 'medium',
    pages: [
      'contributing',
      'code-of-conduct',
      'support',
      'resources'
    ],
    description: 'Comunidade'
  }
};

// Integra√ß√µes brasileiras espec√≠ficas que devemos ter
const BRAZILIAN_INTEGRATIONS = {
  'financeiro': {
    priority: 'high',
    integrations: [
      'pix',
      'boleto',
      'itau',
      'bradesco',
      'santander',
      'nubank',
      'mercado-pago',
      'pagseguro',
      'cielo',
      'stone'
    ]
  },
  'governo': {
    priority: 'high',
    integrations: [
      'receita-federal',
      'cnpj',
      'cpf',
      'sintegra',
      'nfe',
      'nfce',
      'sped',
      'e-social'
    ]
  },
  'localizacao': {
    priority: 'medium',
    integrations: [
      'viacep',
      'correios',
      'ibge',
      'maps-google-br',
      'loggi',
      'jadlog'
    ]
  },
  'ecommerce': {
    priority: 'medium',
    integrations: [
      'mercado-livre',
      'americanas',
      'magazine-luiza',
      'shopee',
      'olx',
      'enjoei'
    ]
  }
};

class ContentGapAnalyzer {
  constructor() {
    this.gaps = [];
    this.existingContent = new Map();
    this.recommendations = [];
  }

  async analyzeGaps() {
    console.log('üîç Iniciando an√°lise de lacunas de conte√∫do...\n');
    
    // 1. Mapear conte√∫do existente
    await this.mapExistingContent();
    
    // 2. Analisar lacunas da documenta√ß√£o oficial
    await this.analyzeOfficialDocsGaps();
    
    // 3. Analisar lacunas de integra√ß√µes brasileiras
    await this.analyzeBrazilianIntegrationsGaps();
    
    // 4. Gerar recomenda√ß√µes
    this.generateRecommendations();
    
    // 5. Apresentar resultados
    this.presentResults();
    
    return {
      gaps: this.gaps,
      recommendations: this.recommendations,
      existingContent: Array.from(this.existingContent.entries())
    };
  }

  async mapExistingContent() {
    console.log('üìã Mapeando conte√∫do existente...');
    
    const scanDirectory = (dir, basePath = '') => {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const fullPath = path.join(dir, item);
        const relativePath = path.join(basePath, item);
        
        if (fs.statSync(fullPath).isDirectory()) {
          scanDirectory(fullPath, relativePath);
        } else if (item.endsWith('.md') || item.endsWith('.mdx')) {
          const content = fs.readFileSync(fullPath, 'utf8');
          const wordCount = content.split(/\s+/).length;
          const isComplete = !content.includes('Em constru√ß√£o') && 
                           !content.includes('TODO') && 
                           wordCount > 100;
          
          this.existingContent.set(relativePath, {
            path: fullPath,
            wordCount,
            isComplete,
            lastModified: fs.statSync(fullPath).mtime
          });
        }
      }
    };
    
    scanDirectory(DOCS_PATH);
    console.log(`   ‚úÖ Mapeados ${this.existingContent.size} arquivos`);
  }

  async analyzeOfficialDocsGaps() {
    console.log('üîç Analisando lacunas da documenta√ß√£o oficial...');
    
    for (const [section, info] of Object.entries(OFFICIAL_DOCS_STRUCTURE)) {
      const sectionGaps = [];
      
      for (const page of info.pages) {
        const possiblePaths = [
          `${section}/${page}.md`,
          `${section}/${page}.mdx`,
          `${section}/${page}/index.md`,
          `${section}/${page}/index.mdx`,
          // Varia√ß√µes em portugu√™s
          `${section}/${page.replace(/-/g, '_')}.md`,
          `${section.replace(/-/g, '_')}/${page}.md`,
          // Mapeamentos espec√≠ficos
          this.mapEnglishToPortuguese(section, page)
        ].filter(Boolean);
        
        const exists = possiblePaths.some(p => this.existingContent.has(p));
        
        if (!exists) {
          sectionGaps.push({
            section,
            page,
            priority: info.priority,
            description: info.description,
            suggestedPath: possiblePaths[0],
            type: 'missing'
          });
        } else {
          // Verificar se est√° completo
          const existingPath = possiblePaths.find(p => this.existingContent.has(p));
          const contentInfo = this.existingContent.get(existingPath);
          
          if (!contentInfo.isComplete) {
            sectionGaps.push({
              section,
              page,
              priority: info.priority,
              description: info.description,
              existingPath,
              type: 'incomplete',
              wordCount: contentInfo.wordCount
            });
          }
        }
      }
      
      if (sectionGaps.length > 0) {
        this.gaps.push({
          section,
          priority: info.priority,
          description: info.description,
          gaps: sectionGaps
        });
      }
    }
    
    console.log(`   ‚úÖ Identificadas lacunas em ${this.gaps.length} se√ß√µes`);
  }

  async analyzeBrazilianIntegrationsGaps() {
    console.log('üáßüá∑ Analisando lacunas de integra√ß√µes brasileiras...');
    
    for (const [category, info] of Object.entries(BRAZILIAN_INTEGRATIONS)) {
      const categoryGaps = [];
      
      for (const integration of info.integrations) {
        const possiblePaths = [
          `integracoes-br/${category}/${integration}.md`,
          `integracoes-br/${category}/${integration}.mdx`,
          `integracoes/${category}/${integration}.md`,
          `integracoes/builtin-nodes/${integration}.md`
        ];
        
        const exists = possiblePaths.some(p => this.existingContent.has(p));
        
        if (!exists) {
          categoryGaps.push({
            category,
            integration,
            priority: info.priority || 'medium',
            type: 'missing_brazilian',
            suggestedPath: possiblePaths[0]
          });
        }
      }
      
      if (categoryGaps.length > 0) {
        this.gaps.push({
          section: `integracoes-br-${category}`,
          priority: info.priority || 'medium',
          description: `Integra√ß√µes brasileiras - ${category}`,
          gaps: categoryGaps
        });
      }
    }
    
    console.log(`   ‚úÖ Identificadas lacunas em integra√ß√µes brasileiras`);
  }

  mapEnglishToPortuguese(section, page) {
    const mappings = {
      'getting-started': 'tutorial-basico',
      'using-n8n': 'usando-n8n',
      'integrations': 'integracoes',
      'hosting': 'hosting-n8n',
      'data': 'logica-e-dados/02-data',
      'flow-logic': 'logica-e-dados/01-flow-logic',
      'advanced-ai': 'advanced-ai',
      'api': 'api',
      'embed': 'embed',
      'community': 'comunidade'
    };
    
    const pageMapping = {
      'quickstarts': 'quickstart-rapido',
      'introduction': 'conceitos-basicos',
      'choose-your-n8n': 'instalacao',
      'video-courses': 'cursos-em-video',
      'text-courses': 'cursos-em-texto',
      'editor-ui': 'interface/navegacao-editor-ui',
      'executions': 'execucoes',
      'builtin-nodes': 'builtin-nodes',
      'app-nodes': 'app-nodes',
      'trigger-nodes': 'trigger-nodes',
      'community-nodes': 'community-nodes',
      'creating-nodes': 'criar-nodes'
    };
    
    const mappedSection = mappings[section] || section;
    const mappedPage = pageMapping[page] || page;
    
    return `${mappedSection}/${mappedPage}.md`;
  }

  generateRecommendations() {
    console.log('üí° Gerando recomenda√ß√µes...');
    
    // Agrupar por prioridade
    const criticalGaps = this.gaps.filter(g => g.priority === 'critical');
    const highGaps = this.gaps.filter(g => g.priority === 'high');
    const mediumGaps = this.gaps.filter(g => g.priority === 'medium');
    
    // Recomenda√ß√µes cr√≠ticas
    if (criticalGaps.length > 0) {
      this.recommendations.push({
        priority: 'critical',
        title: 'Conte√∫do Cr√≠tico Faltante',
        description: `${criticalGaps.length} se√ß√µes cr√≠ticas precisam ser criadas`,
        action: 'Criar imediatamente - essencial para usu√°rios b√°sicos',
        sections: criticalGaps.map(g => g.section)
      });
    }
    
    // Recomenda√ß√µes de alta prioridade
    if (highGaps.length > 0) {
      this.recommendations.push({
        priority: 'high',
        title: 'Conte√∫do Importante Faltante',
        description: `${highGaps.length} se√ß√µes importantes precisam ser criadas`,
        action: 'Criar em seguida - importante para usu√°rios avan√ßados',
        sections: highGaps.map(g => g.section)
      });
    }
    
    // Conte√∫do incompleto
    const incompleteCount = this.gaps.reduce((count, section) => {
      return count + section.gaps.filter(g => g.type === 'incomplete').length;
    }, 0);
    
    if (incompleteCount > 0) {
      this.recommendations.push({
        priority: 'medium',
        title: 'Conte√∫do Incompleto',
        description: `${incompleteCount} p√°ginas est√£o incompletas`,
        action: 'Completar conte√∫do existente antes de criar novo',
        type: 'completion'
      });
    }
    
    // Integra√ß√µes brasileiras
    const brazilianGaps = this.gaps.filter(g => g.section.includes('integracoes-br'));
    if (brazilianGaps.length > 0) {
      this.recommendations.push({
        priority: 'high',
        title: 'Integra√ß√µes Brasileiras',
        description: `${brazilianGaps.length} categorias de integra√ß√µes brasileiras faltantes`,
        action: 'Criar diferencial competitivo para mercado brasileiro',
        type: 'brazilian_specific'
      });
    }
    
    console.log(`   ‚úÖ Geradas ${this.recommendations.length} recomenda√ß√µes`);
  }

  presentResults() {
    console.log('\nüìä **AN√ÅLISE DE LACUNAS DE CONTE√öDO**\n');
    
    // Estat√≠sticas gerais
    const totalGaps = this.gaps.reduce((sum, section) => sum + section.gaps.length, 0);
    const criticalGaps = this.gaps.filter(g => g.priority === 'critical').length;
    const highGaps = this.gaps.filter(g => g.priority === 'high').length;
    
    console.log('üìà **Estat√≠sticas Gerais:**');
    console.log(`   üìÑ Arquivos existentes: ${this.existingContent.size}`);
    console.log(`   ‚ùå Lacunas identificadas: ${totalGaps}`);
    console.log(`   üî¥ Cr√≠ticas: ${criticalGaps}`);
    console.log(`   üü† Alta prioridade: ${highGaps}`);
    
    // Lacunas por se√ß√£o
    console.log('\nüîç **Lacunas por Se√ß√£o:**');
    this.gaps.forEach(section => {
      const emoji = section.priority === 'critical' ? 'üî¥' : 
                   section.priority === 'high' ? 'üü†' : 'üü°';
      console.log(`   ${emoji} **${section.section}** (${section.gaps.length} lacunas)`);
      console.log(`      ${section.description}`);
      
      section.gaps.slice(0, 3).forEach(gap => {
        const type = gap.type === 'missing' ? '‚ùå Faltante' : 
                    gap.type === 'incomplete' ? '‚ö†Ô∏è Incompleto' : 'üáßüá∑ BR Espec√≠fico';
        console.log(`      ‚Ä¢ ${type}: ${gap.page || gap.integration}`);
      });
      
      if (section.gaps.length > 3) {
        console.log(`      ... e mais ${section.gaps.length - 3} lacunas`);
      }
      console.log('');
    });
    
    // Recomenda√ß√µes
    console.log('üí° **Recomenda√ß√µes Priorit√°rias:**');
    this.recommendations.forEach((rec, index) => {
      const emoji = rec.priority === 'critical' ? 'üî¥' : 
                   rec.priority === 'high' ? 'üü†' : 'üü°';
      console.log(`   ${emoji} **${rec.title}**`);
      console.log(`      ${rec.description}`);
      console.log(`      ‚û°Ô∏è  ${rec.action}\n`);
    });
    
    // Pr√≥ximos passos
    console.log('üéØ **Pr√≥ximos Passos Recomendados:**');
    console.log('   1. Foque primeiro no conte√∫do CR√çTICO');
    console.log('   2. Complete p√°ginas incompletas antes de criar novas');
    console.log('   3. Priorize integra√ß√µes brasileiras para diferencial');
    console.log('   4. Use este relat√≥rio para criar issues espec√≠ficas');
    console.log('   5. Estabele√ßa cronograma de cria√ß√£o de conte√∫do');
  }

  async createGitHubIssues() {
    if (!process.env.GITHUB_TOKEN) {
      console.log('‚ö†Ô∏è  GITHUB_TOKEN n√£o encontrado. Pulando cria√ß√£o de issues...');
      return;
    }

    try {
      // Usar import din√¢mico para o Octokit
      const { Octokit } = await import('@octokit/rest');
      const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });
      
      console.log('\nüöÄ Criando issues baseadas na an√°lise de lacunas...');
      
      // Issue principal com relat√≥rio completo
      const reportBody = this.generateReportMarkdown();
      
      const { data: mainIssue } = await octokit.rest.issues.create({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        title: `üîç An√°lise de Lacunas de Conte√∫do - ${new Date().toISOString().split('T')[0]}`,
        body: reportBody,
        labels: ['üìù Documenta√ß√£o', 'üîç Auditoria', 'üìä An√°lise', 'üìã Planejamento']
      });
      
      console.log(`  ‚úÖ Issue principal criada: ${mainIssue.html_url}`);
      
      // Issues espec√≠ficas para se√ß√µes cr√≠ticas
      const criticalSections = this.gaps.filter(g => g.priority === 'critical');
      
      for (const section of criticalSections) {
        const issueBody = this.generateSectionIssueBody(section);
        
        try {
          const { data: sectionIssue } = await octokit.rest.issues.create({
            owner: REPO_OWNER,
            repo: REPO_NAME,
            title: `üî¥ [CR√çTICO] Criar se√ß√£o: ${section.section}`,
            body: issueBody,
            labels: ['üìù Documenta√ß√£o', 'üî¥ Cr√≠tica', 'üÜï Cria√ß√£o', 'üìã Epic']
          });
          
          console.log(`  ‚úÖ Issue cr√≠tica criada: ${sectionIssue.html_url}`);
        } catch (error) {
          console.log(`  ‚ùå Erro ao criar issue para ${section.section}: ${error.message}`);
        }
      }
      
    } catch (error) {
      console.log(`‚ùå Erro ao criar issues: ${error.message}`);
    }
  }

  generateReportMarkdown() {
    const totalGaps = this.gaps.reduce((sum, section) => sum + section.gaps.length, 0);
    
    return `# üîç An√°lise de Lacunas de Conte√∫do

## üìä Resumo Executivo
- **Arquivos existentes:** ${this.existingContent.size}
- **Lacunas identificadas:** ${totalGaps}
- **Se√ß√µes com lacunas:** ${this.gaps.length}

## üéØ Recomenda√ß√µes Priorit√°rias
${this.recommendations.map(rec => `
### ${rec.priority === 'critical' ? 'üî¥' : rec.priority === 'high' ? 'üü†' : 'üü°'} ${rec.title}
**Descri√ß√£o:** ${rec.description}
**A√ß√£o:** ${rec.action}
`).join('\n')}

## üìã Lacunas Detalhadas
${this.gaps.map(section => `
### ${section.priority === 'critical' ? 'üî¥' : section.priority === 'high' ? 'üü†' : 'üü°'} ${section.section}
**Descri√ß√£o:** ${section.description}
**Lacunas:** ${section.gaps.length}

${section.gaps.map(gap => `- ${gap.type === 'missing' ? '‚ùå' : gap.type === 'incomplete' ? '‚ö†Ô∏è' : 'üáßüá∑'} ${gap.page || gap.integration}`).join('\n')}
`).join('\n')}

---
*An√°lise gerada automaticamente em ${new Date().toLocaleString('pt-BR')}*`;
  }

  generateSectionIssueBody(section) {
    return `## üéØ Objetivo
Criar conte√∫do completo para a se√ß√£o **${section.section}** identificada como ${section.priority.toUpperCase()} na an√°lise de lacunas.

## üìã Conte√∫do Faltante
${section.gaps.map(gap => `- [ ] **${gap.page || gap.integration}** ${gap.type === 'incomplete' ? '(incompleto)' : '(faltante)'}`).join('\n')}

## üìù Descri√ß√£o
${section.description}

## ‚úÖ Crit√©rios de Aceita√ß√£o
- [ ] Todo conte√∫do listado criado
- [ ] Conte√∫do testado e funcional
- [ ] Linguagem clara e did√°tica
- [ ] Exemplos pr√°ticos inclu√≠dos
- [ ] Navega√ß√£o funcionando

## üéØ Impacto
**${section.priority.toUpperCase()}** - ${section.priority === 'critical' ? 'Essencial para funcionamento b√°sico' : 'Importante para experi√™ncia completa'}

## üìä Prioridade
Esta se√ß√£o foi identificada como **${section.priority}** na an√°lise autom√°tica de lacunas de conte√∫do.`;
  }
}

// Fun√ß√£o principal
async function main() {
  try {
    const analyzer = new ContentGapAnalyzer();
    const results = await analyzer.analyzeGaps();
    
    // Criar issues se solicitado
    if (process.argv.includes('--create-issues')) {
      await analyzer.createGitHubIssues();
    } else {
      console.log('\nüí° Para criar issues automaticamente, execute:');
      console.log('   node scripts/analyze-content-gaps.js --create-issues');
    }
    
    // Salvar relat√≥rio em arquivo
    if (process.argv.includes('--save-report')) {
      const reportPath = path.join(__dirname, '..', 'content-gaps-report.md');
      fs.writeFileSync(reportPath, analyzer.generateReportMarkdown());
      console.log(`\nüìÑ Relat√≥rio salvo em: ${reportPath}`);
    }
    
  } catch (error) {
    console.error('‚ùå Erro durante an√°lise:', error.message);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

module.exports = { ContentGapAnalyzer };